### 背景
秒杀倒计时效果，使用CountDownTimer，CountDownTimer对外的API 
```
override fun onTick(millisUntilFinished: Long)
override fun onFinish()
```
- 在onTick与onFinish里更新对应的view效果，常规需求。

### 但使用时，计时并未与Activity的生命周期绑定
那么内存泄漏就可能会出现，就像Handler的内存泄漏一样。非静态内部类持有外部对象的引用，在onTick或onFinish方法中的view对象仍持有Activity实例，在GC时，这些对象无法被销毁，而导致内存泄漏。

由于我们项目中是首页MainActivity展示这个倒计时，而首页的生命周期与整个app一致，于是竟然忽略了这个问题，开发过程中隐约感觉这里会出问题，但是未继续坚持。
- ┭┮﹏┭┮ 每一次对模糊的容忍，都会被打响亮的耳光


修复方案
1. 方案一，在MainActivity销毁时，通过消息或者回调的方式让倒计时停止，但是这样这些view是否能够被销毁呢？TODO 待验证 判断应该是不可以。

2. 方案二，通过弱引用的方式。在GC扫描时，弱引用对象能够感知到，此时通过weakReference.get()获取到的引用为null  此时不可以再对view进行更新等持有操作。 具体代码的实现
```
通用的CountDownTimer且使用了泛型，可赞
open class SafeCountDownTimer<T>(
	reference: T,
	millisInFuture: Long,
	countDownInterval: Long
) : CountDownTimer(millisInFuture, countDownInterval) {
	val reference // 与倒计时关联的
			: WeakReference<T> = WeakReference<T>(reference)

	override fun onTick(millisUntilFinished: Long) {
		if (reference.get() == null) {
			cancel()
		}
	}

	override fun onFinish() {
		if (reference.get() == null) {
			cancel()
		}
	}
}
```

```
	private fun startTime(bean: HomeSecKill, time: Long) {
		limitTimer = object : SafeCountDownTimer<HomeFragmentSecKillProvider>(this, time, 1000) {
			override fun onTick(millisUntil: Long) {
				super.onTick(millisUntil)
				limitTimer?.reference?.get()?.run {
					updateUI()
				}
			}

			override fun onFinish() {
				super.onFinish()
				limitTimer?.reference?.get()?.run {
					resetCountTime()
                    updateUI()
				}
			}
		}
		limitTimer?.start()
	}
```

这里要注意2个容易存在的误区
1. 弱引用对象一定是在updateUI中的所有的view，而不是其中一两个，这里我们可以使用整个ViewGroup，这样才能确保内部类里的引用都能与弱引用关联上

2. 代码在这里的写法不可以是
if(limitTimer?.reference?.get() == null) {
    return
}
updateUI()
这样代码确认未执行到，但是对象的引用并没有与弱引用关联起来，依然被强引用。

3. 非静态内部类改为静态内部类

TODO 了解下弱引用的使用




