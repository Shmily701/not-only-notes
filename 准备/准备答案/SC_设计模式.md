设计原则
SOLID
S 单一职责原则  一个类应该仅有一个引起它变化的原因
O 开闭原则     对扩展开发，对修改关闭
L 里氏替换原则  子类必须能够替换他们的父类型，因为对扩展开放，此原则避免扩展带来的错误。
I 接口隔离原则  接口紧缩，避免不必要的依赖
D 依赖反转原则  依赖抽象而不是依赖具体， 高、低模块，具体实现都应该依赖于抽象 

常用的设计模式
工厂方法、生成器模式、装饰模式、观察者模式，策略模式。
关于设计模式的思考
套路方法：
    每一个类别都是一个独立的状态或类，只做一件事，这些类别都是并列的兄弟关系; 有一个管理类，负责管理，封装状态的切换变化，
    对外使用仅暴露管理类，状态切换客户端无感知。

1. 观察者模式 
    eg：XXXView.addXXXListenter  ListView.setAdapter
    被观察者 往往是资源 数据 状态  与观察者之间一般是1对多的关系，他们之前通过注册监听的方式进行关联
    当被观察者发生变化时，被观察的变化通过这个关联 能够使得观察者感知。
    场景：一对多的依赖关系

2. 工厂模式 
    1. 简单工厂：「为创建对象而定义类」  定义一个类来负责创建其他类的实例，被创建的类往往有相同的父类
    2. 工厂方法：「为创建对象而定义接口」定义一个创建对象的接口，将类实例化的过程延迟到子类
    优点：解耦实现，不实现也可以编码，易扩展新产品
    3. 抽象工厂：「为创建一系列对象而定义接口」为一系列相关对象或相互依赖的对象创建一个接口。与工厂方法很像，但它是为一个产品簇的场景。 
    优点：分离接口和实现，构建产品簇变得方便。
    缺点：类层次复杂化，不易扩展（扩展新产品与要修改抽象工厂接口）
    场景：共同的父类，需要构建有个性，定制化的子类。

3. 单例模式


4. 生成器模式
    将对象的构造与表示分离，使同样的构建过程可以创建不同的表示，它是将一个复杂的对象分解为多个简单的对象，然后一步一步构建而成。
    必要的构建 与非必要的构建参数 链式的方式追剧连接。
    优点：
    1. 将对象的表现与构建的解耦，使得构建可以复用。
    2. 对同一个构建过程，配置不同的生成器实现，会生成不同表现的对象。

    做法
    1. 构建一个Builder接口，定义了如何构建的方式，提供灵活扩展切换部件的方法。
    2. 负责整体的构建。

    优点：松散耦合 更好的复用 提供了方便的产品构建
    提供build方法构建对象（必要的参数）私有构造方法。
    并支持通过调用set的方式，链式拼接并返回对象实例。

    核心：分离整体构建与部件构造。将部件的构造灵活提供，便于切换。


5. 策略模式
    模式匹配：'不同场景''不同规则'的关键字
    策略模式：封装了算法的变化，使他们之间可以互相替换，且算法的变化，使用者无感知。
    实际代码：以相同的方式调用所有的算法，减少了算法与使用者之间的耦合。

6. 适配器模式 转换匹配，复用已有的功能 当然可以在适配器里实现扩展，智能适配器。 用的是对象组合的方式。 
让原本接口不兼容的类可以相互合作。这个定义还好，说适配器的功能就是把一个接口转成另一个接口。



7. 代理委托 


8. 装饰模式 
   `模式匹配`：核心功能 && 附加功能 
   将类的装饰功能搬移出去，简化原有的类，原有的类只有核心功能。
   编写code
   - 1. 每个要装饰的功能放在单独的类中封装，装饰类彼此独立
   - 2. 核心功能与附加功能有共同的抽象父类或接口
   - 3. 附加功能持有核心功能的实例，以此来方便的装饰核心功能

   好处：将类的核心职责与装饰功能分离，可以实现灵活更换装饰。
   场景：数据持久化之前的词汇过滤、数据加密。<所以顺序不能错哦>
   

9. 状态模式
   当对象的行为取决于它的状态，且运行中会根据状态改变行为，可以考虑使用状态模式。
   `模式匹配`：大量if...else switch...case场景
   编写code
   - 1. 每一个状态行为独立封装一个状态类
   - 2. 将状态切换的变化封装到独立的类中，效果：客户端调用时，无感知状态变化。
   - 3. 新增状态时，新增1修改2

10. 责任链模式
    责任链模式（Chain of Responsibility）是一种处理请求的模式，它让多个处理器都有机会处理该请求，直到其中某个处理成功为止。责任链模式把多个处理器串成链，然后让请求在链上传递。
    `模式匹配`: 请求模式，多个处理器处理请求。

    变种：
    - 1. 每个Handler都有机会处理Request，通常这种责任链被称为拦截器（Interceptor）或者过滤器（Filter），它的目的不是找到某个Handler处理掉Request，而是每个Handler都做一些工作
    - 2. 通过某个Handler手动调用下一个Handler来传递Request

    责任链模式是一种把多个处理器组合在一起，依次处理请求的模式；好处是添加新的处理器或者重新排列处理器非常容易；经常用在拦截、预处理请求等。







