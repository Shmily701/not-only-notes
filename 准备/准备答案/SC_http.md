2XX 成功
200 请求成功 ok
204 请求成功，未有实体返回
205 告知浏览器，清除页面表单元素
206 范围请求的响应

3XX 重定向
300 Multiple Choice (多种选择)该请求有多种可能的响应，用户需选择其中一个。
301 永久重定向
302 临时重定向 同307 但307遵守了禁止POST变成GET 但302未遵守
303 同302 但明确表示客户端应采用GET方法获取资源
304 资源未更新

4XX 客户端错误
401 需认证
403 未有权限
404 无法找到资源
499 
    1、请求服务端时间过长，超过了客户端设置的超时机制，客户端主动断开链接。
    2、连续快速发送请求，会被认为非安全连接，主动断开了客户端链接。

5XX 服务端错误
500 服务端内部错误
502 收到响应，但无效
503 服务不可用
504 因超时而未收到响应
505 Http版本问题

利用TCP/IP协议数据的传递
从发送端->接收端
发送端每通过一层增加首部
接收端每通过一层删除首部
看图 图解HTTP

应用层 协议: HTTP DNS FTP
传输层 协议: TCP
网络层 协议: IP
链路层  

以IPv4为例，网络地址由32个二进制位组成。从0.0.0.0到255.255.255.255
IP地址分为两部分，前一部分代表网络，后一个部分代码主机。
例如 IP地址172.16.254.1，这是一个32位的地址，假定它的网络部分是前24位（172.16.254），那么主机部分就是后8位（最后的那个1）。处于同一个子网络的电脑，它们IP地址的网络部分必定是相同的，也就是说172.16.254.2应该与172.16.254.1处在同一个子网络。

> 但是，仅从IP地址，我们无法判断出网络部分是前24位还是前16位，甚至前28位。
所以，我们需要用到子网掩码。
"子网掩码"，就是表示子网络特征的一个参数。形式上等同于IP地址，也是一个32位二进制数字，它的网络部分全部为1，主机部分全部为0 如果已知网络部分是前24位。
那么就是24个1代表网络部分，后8个0代表主机部分。
知道"子网掩码"，即可判断任意两个IP是否处于同一子网络，方法是：
将两个IP地址与子网掩码做AND运算，然后比较结果，相同则表示在同一个子网络中。

https://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html

与HTTP关系密切的协议
IP  位于网络层，IP协议的作用是把各种数据包传送给对方 寻址传输数据包
    寻址、路由（最终节点为止的转发）。


TCP 传输层 传输数据 确保传输的可靠性。
    TCP协议为了更容易传送大数据才把数据分割，而且TCP协议能够确认数据最终是否送达到对方。

DNS 应用层 域名映射IP地址 DNS劫持域名指向了错误的地址。
ARP协议（Address Resolution Protocol）。地址解析协议，根据通信方的IP地址就可以反查出对应的MAC地址。

http HyperText Transfer Protocol，超文本传输协议，未加密
Https 安全的超文本传输协议，协议用于对Http协议传输的数据进行加密
HTTP+加密+认证+完整性保护=HTTPS  
1. 加密 通信过程加密
2. 认证 > 「证书可证明服务端或客户端的身份」
3. 完整性保护
HTTP直接和TCP通信，当使用SSL时，则演变成先和SSL通信，再由SSL与TCP
通信。HTTPS是披着SSL协议外壳的HTTP。中间层，保护层。


### SSL协议加密方式 SSL工作过程
SSL是一个独立的协议，是非常广泛的网络安全技术。
SSL首先对'对称加密的密钥'使用公钥进行非对称加密，链路建立好之后，SSL对传输内容使用对称加密。
对称加密 <explain: 加密和解密同用一个密钥>
速度快，可加密内容较多，用来加密会话过程中的消息
公钥加密 <explain: 公钥加密，用私钥解密>
加密速度较慢，但能提供更好的身份认证技术，用来加密对称加密的密钥

HTTPS采用混合加密方式
1. 建立链接时，使用公钥加密的方式，交换后续对称加密的密钥
2. 通过对称加密的方式进行通信

#### http单向认证和双向认证
除了客户端需要认证服务端以外，增加了服务端对客户端的认证：
在客户端对服务端认证通过后，将自己的证书及公钥发送至服务端，
服务端对客户端证书进行校验，校验结束后，获得客户端公钥，公钥加密将数据传输给客户端
https://cloud.tencent.com/developer/article/1171381

### GET请求与POST请求的区别 {语义区别}
    四大误区：
    错误1：{长度限制} GET对数据长度有限制，当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。POST无限制。
    这不是GET的长度限制，这是URL的长度限制。

    错误2：{编码}  GET只允许 ASCII 字符。POST没有限制。编码说的也是URL，POST也可以通过URL查询

    错误3：{安全性} GET 的安全性较差，因为所发送的数据是 URL 的一部分。敏感信息直接可见。POST请求也可以这样，GET请求也可以使用body。

    错误4：{请求次数} GET产生一个TCP数据包；POST产生两个TCP数据包。对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）； 而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。
    这里的POST请求两次，是上传请求体与请求头分批请求处理的习惯：
    eg：上传文件 请求url包含文件名称，请求体是尺寸为几百兆的压缩二进制流。
    可以先处理请求头，如果无权限或文件名不合法，那么就不再处理请求体了，如果通过，服务器返回100 继续，客户端再将剩下的数据发给服务器。如果请求体数据不多，一次性全发给服务端更好。

    ### RFC7231语义区别
    GET的语义就是「获取资源」，POST的语义是「处理资源」，那么在具体实现这两个方法时，就必须考虑其语义，做出符合其语义的行为。

    GET的语义是请求获取指定的资源。GET方法是安全、幂等、可缓存的（除非有 Cache-ControlHeader的约束。反复读取不应该对访问的数据有副作用，无副作用称为"幂等"。 显然对一个url反复访问，读取，是幂等（无副作用）的行为。

    POST的语义是根据请求负荷（报文主体）对指定的资源做出处理，具体的处理方式视资源类型而不同。POST不安全，不幂等，（大部分实现）不可缓存。
    
    所以如果有区别，从这个三个维度去理解思考。






Today
==========================
客户端如何认证服务端？
服务端如何认证客户端？ 

http 1.0 2.0 3.0的区别

范围请求怎么请求？head 
=========================



断点续传
服务端需要记住已下载的内容，这样下次可以跳过之前已下载的部分。
方案：服务端保存已下载切片的hash，客户端每次






