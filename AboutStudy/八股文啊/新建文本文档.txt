《八股文》
Li Ponda
214个笔记

◆ 1

>> - DNS优化：HttpDNS

>>  连接优化：长连接（从 HTTP/1.1 开始支持了长连接，但是 HTTP/2 中引入了多路复用的技术）

>> HTTP 属于应用层协议，在传输层使用 TCP 协议，在网络层使用IP协议

>> 所以 HTTP 的长连接本质上是 TCP 长连接，

>> 域名过多面临下面几个问题：长连接的复用效率降低;每个域名都需要经过 DNS 服务来解析服务器 IP；HTTP 请求需要跟不同服务器同时保持长连接，增加了客户端和服务端的资源消耗。

>> 通过startForeground将进程设置为前台进程，做前台服务，优先级和前台应用一个级别

>> 获取不到锁就马上进入阻塞状态的锁称之为重量级锁。

2023/03/22发表想法
JAVA1.6为synchronized做了优化，增加了从偏向锁到轻量级锁的过渡。
>> 线程从运行态进入阻塞态这个过程是非常耗时的，因为不仅需要保存线程此时的执行状态，上下文等数据，还涉及到用户态到内核态的转换。当然，把线程从阻塞态唤醒也是一样非常耗时的

2023/03/22发表想法
涉及用户模式到内核模式的转换
>> 线程从运行态进入阻塞态这个过程是非常耗时的，因为不仅需要保存线程此时的执行状态，上下文等数据，还涉及到用户态到内核态的转换。当然，把线程从阻塞态唤醒也是一样非常耗时的

>> 线程从运行态进入阻塞态这个过程是非常耗时的，因为不仅需要保存线程此时的执行状态，上下文等数据，还涉及到用户态到内核态的转换。当然，把线程从阻塞态唤醒也是一样非常耗时的

>> 愿意等待一段时间的锁自旋锁。

>> 自旋锁就是，如果此时拿不到锁，它不马上进入阻塞状态，而是等待一段时间，看这段时间是否有他人把这锁给释放了

>> 如果循环一定的次数还拿不到锁，那么它才会进入阻塞的状态。

2023/03/27发表想法
用户也可以使用参数-XX：PreBlockSpin来自行更改
>> 至于是循环等待几次，这个是可以人为指定一个数字的

>> 至于是循环等待几次，这个是可以人为指定一个数字的

2023/04/02发表想法
自适应自旋锁的理论基础。
>> 之前经常拿到过这个锁，那么我们认为它再次拿到锁的几率非常大，所以循环的次数会多一些。

>> 之前经常拿到过这个锁，那么我们认为它再次拿到锁的几率非常大，所以循环的次数会多一些。

>> 根据线程最近获得锁的状态来调整循环次数的自旋锁，我们称之为自适应自旋锁。

2023/03/27发表想法
采用CAS的方式进行标记
>> #### 轻量级锁

>> #### 轻量级锁

>> 上面我们介绍的三种锁：重量级锁、自旋锁和自适应自旋锁，他们都有一个特点，就是进入一个方法的时候，就会加上锁，退出一个方法的时候，也就释放对应的锁。

>> 加锁这个过程是需要操作系统来帮忙的，是很消耗时间的，为了解决这种动不动就加锁带来的开销，轻量级锁出现了。

>> 采用CAS机制，把这个方法的状态标记为已经有人在执行，退出这个方法时，在把这个状态改为了没有人在执行了

2023/03/27发表想法
CAS包含了3个操作数——需要读写的内存位置V、进行比较的值A和拟写入的新值B。当且仅当V的值等于A时，CAS才会通过原子方式用新值B来更新V的值，否则不会执行任何操作。无论位置V的值是否等于A，都将返回V原有的值。
>> 需要CAS机制来保证操作的原子性

>> 需要CAS机制来保证操作的原子性

>> 轻量级锁适合用在那种很少出现多个线程竞争一个锁的情况，也就是说，适合那种多个线程总是错开时间来获取锁的情况。

>> 偏向锁认为轻量级锁每次进入一个方法都需要用CAS来改变状态，退出也需要改变，多麻烦。

>> 采用CAS机制，把这个方法标记为有人在执行了，和轻量级锁加锁有点类似，并且也会把该线程的 ID 记录进去，相当于记录了哪个线程在执行。

>> 然后当这个线程退出方法时，它不会改变这个方法的状态，而是直接退出来

>> 当这个线程想要再次进入这个方法时，会判断一下这个方法的状态，如果这个方法已经被标记为有人在执行了，并且线程的ID是自己，那么它就直接进入这个方法执行，啥也不用做。

>> 第一次进入需要CAS机制来设置，以后进出就啥也不用干了，直接进入退出。

>> 其他线程一看这个方法的ID不是自己，这个时候说明，至少有两个线程要来执行这个方法了，这意味着偏向锁已经不适用，这个时候就会从偏向锁升级为轻量级锁

>> 最开始我们说的三种锁，重量级锁、自旋锁和自适应自旋锁，进入方法之前，就一定要先加一个锁，这种我们为称之为悲观锁。悲观锁认为如果不事先加锁就会出事，这种想法确实悲观了点，这估计就是悲观锁的来源了。

>> 乐观锁却相反，认为不加锁也没事，我们可以先不加锁，如果出现了冲突再想办法解决，例如 CAS 机制，上面说的轻量级锁，就是乐观锁。不会马上加锁，而是等真的出现了冲突，再想办法解决。

>> “GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连，或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。

2023/03/27发表想法
新生代的垃圾回收算法:标记-复制
老年代的垃圾回收算法:标记-整理CMS等，也有和稀泥法，标记-清除+标记-整理
>> 新生代（Young Generation）和老年代（Old Generation）两个区域

2023/03/27发表想法
新生代的垃圾回收算法:标记-复制
老年代的垃圾回收算法:标记-整理CMS等，也有和稀泥法，标记-清除+标记-整理
>> 新生代（Young Generation）和老年代（Old Generation）两个区域

>> 新生代（Young Generation）和老年代（Old Generation）两个区域

>> 标记和清除两个过程的执行效率都随对象数量增长而降低；第二个是内存空间的碎片化问题

>> 如果内存中多数对象都是存活的，这种算法将会产生大量的内存间复制的开销

>> 将可用内存缩小为了原来的一半

2023/03/29发表想法
分配担保，一定是新生代，新生代才有被担保的可能性。
>> 如果不想浪费50%的空间，就需要有额外的空间进行分配担保

2023/03/29发表想法
分配担保，一定是新生代，新生代才有被担保的可能性。
>> 如果不想浪费50%的空间，就需要有额外的空间进行分配担保

>> 如果不想浪费50%的空间，就需要有额外的空间进行分配担保

>> 标记-清除算法与标记-整理算法的本质差异在于前者是一种非移动式的回收算法，而后者是移动式的。

>> ParNew收集器实质上是Serial收集器的多线程并行版本，除了同时使用多条线程进行垃圾收集之外，其余的行为包括Serial收集器可用的所有控制参数

◆ 书签
2023/03/27
CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。从名字（包含“Mark Sweep”）上就可以看出CMS收集器是基于标记-清除算法实现的，它的运作过程相对于前面几种收集器来说要更复杂一些，整个过程分为四个步骤，包括：

1）初始标记（CMS initial mark）

2）并发标记（CMS concurrent mark）

3）重新标记（CMS remark）

4）并发清除（CMS concurrent sweep）

 

其中初始标记、重新标记这两个步骤仍然需要“Stop The World”。

>> CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器

>> “通过一个类的全限定名来获取描述该类的二进制字节流”

>> 对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性

>> 在JDK 5之前，字符串加法会转化为StringBuffer对象的连续append()操作，在JDK 5及以后的版本中，会转化为StringBuilder对象的连续append()操作。

>> 如果虚拟机探测到有这样一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部，

>> 资源进行排他性控制

>> 请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放

>> 循环等待条件：存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被链中下一个进程所请求。

2023/03/31发表想法
通过使用“慢启动”与“拥塞避免”的方式，控制发送数据包的“窗口大小”
>> ### 拥塞控制

>> ### 拥塞控制

2023/04/01发表想法
ACK（Acknowledgement），即确认字符，在数据通信中，接收站发给发送站的一种传输类控制字符。表示发来的数据已确认接受无误。ACK信号通常是一个ASCII字符，不同的协议中ACK信号都不一样。当发送方接收到ACK信号时，就可以发送下一个数据。如果发送方没有收到信号，那么发送方可能会重发当前的数据包，也可能停止传送数据。
>> 接收方反馈的ACK

>> 接收方反馈的ACK

>> 不仅浪费了信道资源，还会使网络更加拥塞。因此需要进行拥塞控制。

>> 我们也把 A 一次性连续发送多少个数据包称之为拥塞窗口

>> 指数增长阶段称之为慢启动，把线性增长阶段称之为拥塞避免。

2023/03/31发表想法
接收方收到发送方的数据包，发送确认报文时，告知自己的缓冲区剩余空间，即“接收窗口大小”，如果接收窗口为0，也发送方就会停止发送数据。
>> ### 流量控制

>> ### 流量控制

>> 对发送方发送速率的控制，我们称之为流量控制。接收方每次收到数据包，可以在发送确认报文的时候，同时告诉发送方自己的缓存区还剩余多少是空闲的，我们把缓存区的剩余大小称为接收窗口大小，用变量 win 表示接收窗口的大小。

2023/04/02发表想法
HTTP主要有这些不足，例举如下。
●通信使用明文（不加密），内容可能会被窃听
●不验证通信方的身份，因此有可能遭遇伪装
●无法证明报文的完整性，所以有可能已遭篡改
>> ### HTTPS加密原理

>> ### HTTPS加密原理

>> 因为http的内容是明文传输的，明文数据会经过中间代理服务器、路由器、wifi热点、通信服务运营商等多个物理节点

2023/04/01发表想法
相同嗯秘钥
>> #### 对称加密

>> #### 对称加密

>> 如果通信双方都各自持有同一个密钥，且没有别人知道

2023/04/01发表想法
非对称加密，是通过不同的公钥与私钥来对“对称加密”的秘钥X进行加密传输。传输完成后，通信双方的数据便可由秘钥X加密传输。
>> #### 非对称加密

>> #### 非对称加密

2023/04/04发表想法
明文传输公钥，给了“中间人”可趁之机。
>> 浏览器向网站服务器请求，服务器把公钥A明文传输给浏览器。

>> 浏览器向网站服务器请求，服务器把公钥A明文传输给浏览器。

>> 在双方都不会发现异常的情况下，中间人通过一套“狸猫换太子”的操作，掉包了服务器传来的公钥，进而得到了密钥X

2023/04/04发表想法
这就是为什么需要数字证书的原因，数字证书里有‘证书持有者’与‘公钥的’信息。那么怎么保证数字证书不被篡改？答案是数字签名。
>> 浏览器无法确认收到的公钥是不是网站自己的。

>> 浏览器无法确认收到的公钥是不是网站自己的。

2023/04/04发表想法
服务端为每个“客户端”维护一个sessionID，在TLS握手阶段传给“客户端”，当服务端接收到被公钥A加密的密钥X后，用私钥A'解码，并将密钥X存在sessionID下。
>> 服务器会为每个浏览器（或客户端软件）维护一个session ID，在TLS握手阶段传给浏览器

>> 服务器会为每个浏览器（或客户端软件）维护一个session ID，在TLS握手阶段传给浏览器

2023/04/03发表想法
服务端缓存了许多浏览器或客户端的密钥，当接收请求数据时，需要找到对应的客户端或浏览器密钥解密，通过将sessionID与密钥“绑定”，就如同通过key查value。
>> 服务器会把该密钥存到相应的session ID下，之后浏览器每次请求都会携带session ID，服务器会根据session ID找到相应的密钥并进行加解密操作

>> 服务器会把该密钥存到相应的session ID下，之后浏览器每次请求都会携带session ID，服务器会根据session ID找到相应的密钥并进行加解密操作

>> 网站在使用HTTPS前，需要向CA机构申领一份数字证书

>> 数字证书里含有证书持有者信息、公钥信息等

>> 浏览器从证书里获取公钥就行了，证书就如身份证，证明“该公钥对应该网站”

>> “证书本身的传输过程中，如何防止被篡改”

2023/04/10发表想法
实际证书并没有防止“篡改行为，只是增加了检验机制，确保在证书被篡改后能够被检验不通过”
>> “证书本身的传输过程中，如何防止被篡改”

>> 数字证书的“防伪技术”，这里的“签名”就叫数字签名

>> 1. CA机构拥有非对称加密的私钥和公钥。

2023/04/04发表想法
CA是证书的签发机构，它是公钥基础设施（Public Key Infrastructure，PKI）的核心。CA是负责签发证书、认证证书、管理已颁发证书的机关。
>> 1. CA机构拥有非对称加密的私钥和公钥。

>> 对hash后的值用私钥加密，得到数字签名S。

>> 明文和数字签名共同组成了数字证书，这样一份数字证书就可以颁发给网站了

2023/04/04发表想法
数字证书包含的信息
1. 证书持有者的信息
2. 公钥信息
3. 明文T
4. 签名S

>> 明文和数字签名共同组成了数字证书，这样一份数字证书就可以颁发给网站了

2023/04/04发表想法
浏览器有CA机构的公钥信息，可以对签名S解密。
>> 用CA机构的公钥对S解密（由于是浏览器信任的机构，所以浏览器保有它的公钥），得到S’。

>> 用CA机构的公钥对S解密（由于是浏览器信任的机构，所以浏览器保有它的公钥），得到S’。

>> 显然通过以上步骤，T’应当等于S‘，除非明文或签名被篡改。

2023/04/06发表想法
有可能篡改，但是无法通过浏览器校验。
>> ##### 中间人有可能篡改该证书吗？

>> ##### 中间人有可能篡改该证书吗？

2023/04/11发表想法
你个大聪明
>> 其实这并不会发生，因为证书里包含了网站A的信息

>> 其实这并不会发生，因为证书里包含了网站A的信息

>> 非对称加密效率较差

2023/04/06发表想法
 sleep  不会释放锁，但是会让出cpu执行权
>> sleep：线程会释放执行权，但不是不释放锁。

>> sleep：线程会释放执行权，但不是不释放锁。

>> ### 进程间通信方式

2023/04/11发表想法
管道的通信方式效率低下，a进程给b进程传输数据，只能等待b进程提取数据之后a进程才能返回
>> - 管道

>> - 管道

>> 管道的通信方式效率低下，a进程给b进程传输数据，只能等待b进程提取数据之后a进程才能返回

>> 如果 a 进程发送的数据占的内存比较大，并且两个进程之间的通信特别频繁的话，消息队列模型就不大适合了

2023/04/12发表想法
从一个进程但另一个进程的内存拷贝，这是避免不了的。除非共享内存，CopyOnWrite的方式也是不错的选择。
>> 因为 a 发送的数据很大的话，意味发送消息（拷贝）这个过程需要花很多时间来读内存。

>> 因为 a 发送的数据很大的话，意味发送消息（拷贝）这个过程需要花很多时间来读内存。

>>  共享内存：共享内存这个通信方式就可以很好的解决拷贝所消耗的时间了；但它存在多进程竞争内存的问题

2023/04/15发表想法
这个问题需要从TCP/IP协议的分层设计来回答
分层的目的：模块化，解耦，降低更换成本。
应用层：决定了向用户提供应用服务时的通信。【应用层协议：FTP、DNS、Http】
传输层：提供数据传输{将从应用层收到的HTTP报文分割+打标记与端口号转发至网络层}。【传输层协议：TCP、UDP】
网络层：IP数据包 （TCP报文+MAC地址转发给数据链路层）。
数据链路层：传输的数据（IP数据包+MAC地址）

>> 计算机是如何把数据发送给另一台计算机的

>> 计算机是如何把数据发送给另一台计算机的

2023/04/15发表想法
数据的传输从发送方沿着分层设计顺流而下，接收方沿着分层设计逆流而上。
>>  应用层：HTTP报文（HTTP数据）

>>  应用层：HTTP报文（HTTP数据）

◆ 书签
2023/04/17
- 组件化体现过程，更像是一种开发模式，不同功能模块的代码做物理隔离，比如分到不同的module或project中。组件化不具备插件化运行时动态加载的特性。

 

### 为什么要用组件化

1. 高效：因为每个组件都是一个独立的app，可以独立运行，所以开发人员只需要在自己的组件中开发测试即可，开发效率更高，编译速度更快

2. 稳定：每个组件都是高内聚的模块，可以进行单元测试；一个组件代码发生变化基本上也不会影响其他组件

◆ 书签
2023/04/17
### 组件化结构

每个团队对自己项目的层级划分都不太一样，粗略的说，可以分成下面三层：

- 业务层：每个app的业务部分，比如feed流、个人中心、登录注册等

- 业务支撑层：比如打点、配置中心

- 公共层：比如图片、网络、UI基础组件

 

### AOP

面向切面编程，可以对业务逻辑的各个部分进行隔离，降低耦合，提高代码的可重用性。应用场景有事务、日志管理等。

2023/04/17发表想法
编译器的提示避免了空指针问题。
>>  空安全，可以避免大部分Java中的空指针异常

>>  空安全，可以避免大部分Java中的空指针异常

>> 就是把设计模式中的“装饰模式”内置到语法层面了

>>  抛弃了CheckedException，调用声明了抛出CheckedException的方法不加try-catch能够正常编译

>> 这个 compareAndSet 操作只对应操作系统的一条硬件操作指令，尽管看似有很多操作在里面，但操作系统能够保证他是原子执行的。

2023/03/22发表想法
原子操作类，指的是java.util.concurrent.atomicb包下，一系列以Atomic开头的包装类。如AtomicBoolean，AtomicUInteger，AtomicLong 。它们分别用Booeal，Integer，Long类型的原子性操作。
>> Java中提供的CAS原子类有AtomicInteger、AtomicLong等。

>> Java中提供的CAS原子类有AtomicInteger、AtomicLong等。

2023/04/15发表想法
Java层和Native层的MessageQueue通过JNI建立关联，从而使得MessageQueue成为Java层和Native层的枢纽，既能处理上层消息，也能处理native层消息，而Handler/Looper/Message这三大类在Java层与Native层之间没有任何的关联，只是分别在Java层和Native层的消息模型中具有相似的功能，都是彼此独立的，各自实现相应的逻辑。

这里我们可以回答为什么java层的loop方法是死循环但却不会消耗性能这个问题：

因为java层的消息机制是依赖native层的消息机制来实现的，而native层的消息机制是通过Linux的管道和epoll机制实现的，epoll机制是一种高效的IO多路复用机制【单进程/线程同时监测若干个文件描述符是否可以执行IO操作的能力】， 它使用一个文件描述符管理多个描述符，java层通过mPtr指针也就共享了native层的epoll机制的高效性，当loop方法中取不到消息时，便阻塞在MessageQueue的next方法，而next方法阻塞在nativePollOnce方法，nativePollOnce方法通过JNI调用进入到native层中去，最终nativePollOnce方法阻塞在epoll_wait方法中，epoll_wait方法会让当前线程释放CPU资源进入休眠状态，等到下一个消息到达(mWakeEventFd【唤醒文件描述符】会往管道写入字符)或监听的其他事件发生时就会唤醒线程，然后处理消息，所以就算loop方法是死循环，当线程空闲时，它会进入休眠状态，不会消耗大量的CPU资源。


>> 在主线程的MessageQueue没有消息时，便阻塞在loop的queue.next()中的nativePollOnce()方法里，此时主线程会释放CPU资源进入休眠状态，直到下个消息到达或者有事务发生，通过往pipe管道写端写入数据来唤醒主线程工作

>> 在主线程的MessageQueue没有消息时，便阻塞在loop的queue.next()中的nativePollOnce()方法里，此时主线程会释放CPU资源进入休眠状态，直到下个消息到达或者有事务发生，通过往pipe管道写端写入数据来唤醒主线程工作

2023/04/15发表想法
定义：单进程/线程下同时监测若干个文件描述符，是否可以执行IO操作的能力。同时关注多个文件描述符动态，哪个可用处理哪个。
单进程/线程的并发，我们知道的一种方式是：CPU处理的时分复用；还有一种方式就是IO多路复用，解决的本质问题是在用更少的资源完成更多的事。
>> IO多路复用机制

2023/04/15发表想法
nativePollOnce方法阻塞在epoll_wait方法中，epoll_wait方法会让当前线程释放CPU资源进入休眠状态，等到下一个消息到达(mWakeEventFd【唤醒文件描述符】会往管道写入字符)或监听的其他事件发生时就会唤醒线程
>> 主线程大多数时候都是处于休眠状态，并不会消耗大量CPU资源

>> 主线程大多数时候都是处于休眠状态，并不会消耗大量CPU资源

>> 进程间通信（IPC）的方式

>> - `activity.attach`中创建了一个`PhoneWindow`

◆ 书签
2023/06/20
Activity、PhoneWindow、DecorView、ViewRootImpl 之间的关系？

- PhoneWindow：是Activity和View交互的中间层，帮助Activity管理View。

- DecorView：是所有View的最顶层View，是所有View的parent。

- ViewRootImpl：用于处理View相关的事件，比如绘制，事件分发，也是DecorView的parent。

>> addToDisplay方法最终会在WMS所在进程的addWindow方法，为窗口分配Surface，而这个Surface就是负责显示最终的界面了，并最终会绘制到屏幕上。

>> ，IOC（Inversion of Control）意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。

>> @ContextConfiguration("classpath:applicationContext4.xml")

>> @Autowired

>> 内核线程的调度成本主要来自于用户态与核心态之间的状态转换，而这两种状态转换的开销主要来自于响应中断、保护和恢复执行现场的成本。

>> 在IntentService内有一个工作线程来处理耗时操作，启动IntentService的方式和启动传统的Service一样，但是当任务执行完后，IntentService会自动停止，而不需要我们手动去控制或者stopSelf()。

>> 每一个耗时操作会以工作队列的方式在IntentService的onHandlerIntent回调方法中执行

>> IPC机制下的高性能传输

>> arcel提供了一套机制，可以将序列化之后的数据写入到一个共享内存（就是Binder的那个共享内存）中，其他进程通过Parcel可以从这块共享内存中读出字节流，并反序列化成对象。

>> Binder 传递缓存有一个限定大小，通常是 1Mb。但同一个进程中所有的传输共享缓存空间。多个地方在进行传输时，即使它们各自传输的数据不超出大小限制，TransactionTooLargeException异常也可能被抛出。

>> 当 MessageQueue 当前没有立即需要处理的消息时，会执行 IdleHandler。IdleHandler 被定义在 MessageQueue 中，它是一个接口。

>> MessageQueue 提供了 add/remove IdleHandler 的方法，是否需要成对使用？

>>  是否可以将一些不重要的启动服务移到 IdleHandler 中去处理？

>> ### IdleHandler 的 queueIdle() 运行在哪个线程？

>> 通过DEX工具将所有的Class文件转换成DEX文件，该过程主要是完成Java字节码转换成Dalvik字节码，压缩常量池以及清除信息等工作

>> 对齐的过程就是将文件中所有的资源文件起始距离都偏移4字节的整数倍，这样通过内存映射访问APK文件的速度会更快

◆ 书签
2023/06/27
### APK安装流程

![](./android/res/apk_install_process.png)

1. 复制APK到/data/app目录下，解压并扫描安装包。

2. 资源管理器解析APK文件

3. 解析AndroidManifest.xml文件，并在/data/data目录下创建对应的应用数据目录

4. 然后对dex文件进行优化，并保存在dalivk-cache目录下

5. 将AndroidManifest.xml中解析出的四大组件信息注册到PackageMangerService中

6. 安装完成后，发送广播

 

### APK卸载流程

>> ### 讲讲你了解的WebView的一切

2023/04/20发表想法
注意方法注册在对应的类名下。
>> - H5向原生通讯：webview.addJavascriptInterface，由webview提供接口

>> - H5向原生通讯：webview.addJavascriptInterface，由webview提供接口

>> ### WebView如何做资源缓存？

>> 开发者只能通过配置HTTP响应头影响浏览器的行为才能间接地影响到这些缓存数据。

>> 数据缓存：分为AppCache和DOM Storage两种，开发者可以自行控制的就是这些缓存资源

>> Android中使用ApplicationCache.db来保存AppCache数据。

2023/04/20发表想法
很像android里的sp存储
>> 有Session Storage和Local Storage两种，分别用于会话级别的存储（页面关闭即消失）和本地化存储（除非主动删除，否则数据永远不会过期）

>> 有Session Storage和Local Storage两种，分别用于会话级别的存储（页面关闭即消失）和本地化存储（除非主动删除，否则数据永远不会过期）

>> - LOAD_DEFAULT: 根据cache-control决定是否从网络上取数据。

>> - LOAD_CACHE_ELSE_NETWORK

>> settings.setCacheMode(WebSettings.LOAD_CACHE_ELSE_NETWORK);

>> Inflate操作会把xml文件实例化成相应的View实例，属于IO操作，是耗时操作。

>> - ListView中元素避免半透明：半透明绘制需要大量乘法计算，在滑动时不停重绘会造成大量的计算，在性能较差的机器上会比较卡。在设计上能不半透明就不半透明。实在要弄就在滑动时把半透明设置成不透明，滑动完再重新设置成半透明。

>> TCP协议为了更容易传送大数据才把数据分割，而且TCP协议能够确认数据最终是否送达到对方。

>> 本地的host文件

>> 本地dns解析器缓存

>> 本地dns服务器

>> HTTPS，其实就是身披SSL协议这层外壳的HTTP。在采用SSL后，HTTP就拥有了HTTPS的加密、证书和完整性保护这些功能。

>> 双向通信流程，客户端除了需要从服务器端下载服务器的公钥证书进行验证外，还需要把客户端的公钥证书上传到服务器端给服务器端进行验证，等双方都认证通过了，才开始建立安全通信通道进行数据传输。

>> Range范围请求。

>> 断点上传怎么实现？需要与服务端约定。

>> 网页中输入url，到渲染界面的整个过程，以及过程中使用了什么协议？

◆ 书签
2023/04/25
3. 向IP地址发送HTTP请求

4. 服务器处理请求

5. 返回响应结果

6. 关闭TCP连接

7. 浏览器解析HTML

8. 浏览器布局渲染

 

### TCP和UDP的区别

1. TCP面向连接；UDP无连接

2. TCP可靠传输，使用流量流量控制和拥塞控制；UDP不可靠传输，不使用流量控制和拥塞控制	

3. TCP只能是一对一通信；UDP支持一对一，一对多，多对一和多对多交互通信

4. TCP面向字节流；UDP面向报文

>> 持久连接的特点是，只要任意一端没有明确提出断开连接，则保持TCP连接状态。

>> 持久连接的好处在于减少了TCP连接的重复建立和断开所造成的额外开销，减轻了服务器的负载。

>> 在HTTP/1.1中，所有连接默认都是持久连接，但在HTTP/1.0内并未标准化。

>> 除了服务器端，客户端也需要支持持久连接。

>> HTTP是无状态协议，它不对之前发生过的请求和响应的状态进行管理。也就是说，无法根据之前的状态进行本次的请求处理

>> 不必保存状态，自然可减少服务器的CPU及内存资源的消耗

2023/04/25发表想法
Cookie的工作机制是用户识别及状态管理
>> Cookie技术通过在请求和响应报文中写入Cookie信息来控制客户端的状态

>> Cookie技术通过在请求和响应报文中写入Cookie信息来控制客户端的状态

>> 服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分。

>> 304 Not Modified（服务器端资源未改变，可直接使用客户端未过期的缓存

>> 。If-Modified-Since用于确认代理或客户端拥有的本地资源的有效性。获取资源的更新日期时间，可通过确认首部字段Last-Modified来确定。

>> Location：可以将响应接收方引导至某个与请求URI位置不同的资源。基本上，该字段会配合3xx:Redirection的响应，提供重定向的URI。

>> ## HTTP优化方案

>> 4.IP直连省去DNS解析时间；

2023/04/26发表想法
从需求的角度简化问题。
>>  内容协商返回最合适的内容

>>  内容协商返回最合适的内容

>> 协议层的优化，比如更优的HTTP版本等

>> - 多路复用(或连接共享)- 头部压缩

>> ### String为什么是不可变的？

>> - 线程安全：由于字符串是不可变的

2023/04/26发表想法
所以在过去String str = ""
str+str1+... 等操作会导致StackOverflow，每一次改变都会在字符串常量池中创建一个字符串对象。
当然后续的java版本对字符串直接的+操作符做了重载，优化为StringBuilder的append方式。
>> 如果一个线程把字符串的值修改为另外一个，那么就会在字符串常量池中创建另外一个字符串，原有的字符串仍然会保持不变。

>> 如果一个线程把字符串的值修改为另外一个，那么就会在字符串常量池中创建另外一个字符串，原有的字符串仍然会保持不变。

>> 。由于字符串是不可变的，这就保证了键值的哈希值不会发生改变，因此在第一次调用 String 类的 hashCode() 方法时，就对哈希值进行了缓存，此后，就一直返回相同的值。由于哈希值被缓存了，这在另外一种层面上提高了哈希表的访问性能，因为哈希值不用重新计算了。 

>> ## Object类的equal和hashcode方法

2023/04/26发表想法
hashCode方法可以重写
>> （生成hash值的公式可能存在问题）

>> （生成hash值的公式可能存在问题）

>> equals()相等的两个对象他们的hashCode()肯定相等，也就是用equal()对比是绝对可靠的。- hashCode()相等的两个对象他们的equal()不一定相等，也就是hashCode()不是绝对可靠的。

2023/04/26发表想法
未复写equals方法时，比较的是两个地址，复写后则为自定义的值。
>> boolean equals(Object obj)：用于比较两个对象是否相等，其实内部比较的就是两个对象地址。

>> boolean equals(Object obj)：用于比较两个对象是否相等，其实内部比较的就是两个对象地址。

>> 支持此方法是为了提高哈希表的性能。

>> equals 方法被覆盖过，则 hashCode 方法也必须被覆盖

>> (“==”基本数据类型比较的是值，引用数据类型比较的是内存地址

2023/05/04发表想法
减少占用内存的时间，或者内存结合硬盘缓存。
>> 比如SoftReference, WeakReference, 硬盘缓存等。

>> 比如SoftReference, WeakReference, 硬盘缓存等。

>> 如果OOM的原因不是try语句中的对象（比如内存泄漏），那么在catch语句中会继续抛出OOM

>> 内部类之所以定义在内部就是为了封装。想要获取内部类对象通常都通过外部类的方法来获取。这样可以对内部类对象进行控制。

2023/05/04发表想法
因为静态内部类并不持有外部类的引用（能够避免不必要的内存泄露）
它就是个外部类
>> - 静态修饰符。
如果内部类被静态修饰，相当于外部类，会出现访问局限性，只能访问外部类中的静态成员。

>> - 静态修饰符。如果内部类被静态修饰，相当于外部类，会出现访问局限性，只能访问外部类中的静态成员。

2023/05/04发表想法
这才符合面向对象的思想
>> 获取锁，或者释放锁的动作应该是锁这个事物更清楚。所以将这些动作定义在了锁当中，并把锁定义成对象。

>> 获取锁，或者释放锁的动作应该是锁这个事物更清楚。所以将这些动作定义在了锁当中，并把锁定义成对象。

◆ 书签
2023/05/04
--count;

 notFull.signal();

 return x;

 } 

 finally {

 lock.unlock();

 }

 } 

 }

```

 

### 线程池

当线程数小于核心池线程数时，只需要添加一个线程并且启动它，如果线程数目大于核心线程池数目，我们将任务放到 workQueue中，如果连WorkQueue满了，那么就要拒绝任务了。

